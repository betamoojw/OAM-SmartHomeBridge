

#include <knx.h>
#include "hardware.h"
#include "knxprod.h"
#include <OpenKNX.h>
#include <Logic.h>
#include "KnxBridge.h"


void progLedOn()
{
  Serial.println("Prog LED ON");
#ifdef ESP32_DEV_BOARD
#if PROG_LED_PIN == 1 // GPIO1 is used for serial TX, to turn on the LED, the serial communication must be stopped
  Serial.flush(true);
  Serial.end(true);
  pinMode(PROG_LED_PIN, OUTPUT);
#endif
#endif
  digitalWrite(PROG_LED_PIN, PROG_LED_PIN_ACTIVE_ON);
}

void progLedOff()
{
  digitalWrite(LED_BUILTIN, !PROG_LED_PIN_ACTIVE_ON);
#ifdef ESP32_DEV_BOARD
#if PROG_LED_PIN == 1 // GPIO1 is used for serial TX, it can be used now again for serial communication
  Serial.begin(115200);
  Serial.println();
#endif
#endif
  Serial.println("Prog LED Off");
}

ICACHE_RAM_ATTR void programButtonPressed()
{
  // Debounce
  static uint32_t lastpressed = 0;
  if (millis() - lastpressed > 200)
  {
    knx.toggleProgMode();
    lastpressed = millis();
  }
}

void setup()
{

   const uint8_t firmwareRevision = 1;
    openknx.init(firmwareRevision);
   // smartmf.init();

    openknx.addModule(1, new Logic());
    openknx.addModule(2, new KnxBridge());
    openknx.setup();


//     // Wire.begin();
// #ifdef ARDUINO_ARCH_RP2040
//     // die defines musst du dann noch setzen
//     Serial1.setRX(KNX_UART_RX_PIN);
//     Serial1.setTX(KNX_UART_TX_PIN);
//     Serial2.setRX(ENO_UART_RX_PIN);
//     Serial2.setTX(ENO_UART_TX_PIN);
// #endif

//     pinMode(PROG_LED_PIN, OUTPUT);
//     digitalWrite(PROG_LED_PIN, HIGH);
//     delay(DEBUG_DELAY);
//     digitalWrite(PROG_LED_PIN, LOW);
// #ifdef KDEBUG_min
//     SERIAL_PORT.begin(115200);
//     SERIAL_PORT.println("Startup called...");
//     ArduinoPlatform::SerialDebug = &SERIAL_PORT;
// #endif


// #ifdef LED_YELLOW_PIN
//     pinMode(LED_YELLOW_PIN, OUTPUT);
//     digitalWrite(LED_YELLOW_PIN, HIGH);
// #endif
//     knx.platform().knxUart(&Serial2);
//     Serial2.end(); // needed, because knxUart calls begin, but this causes a failure in the start

//     knx.setProgLedOffCallback(progLedOff);
//     knx.setProgLedOnCallback(progLedOn);

//     knx.buttonPin(0);
//     knx.setButtonISRFunction(programButtonPressed);

//     // knxRead must be called after buttons are set for knx
//     // all MAIN_* parameters are generated by OpenKNXproducer for correct version checking by ETS
//     // If you want just a bugfix firmware update without ETS-Application dependency, just increase firmwareRevision.
//     // As soon, as you want again a sync between ETS-Application and firmware, set firmwareRevision to 0.
//     const uint8_t firmwareRevision = 0;
//     OpenKNX::knxRead(MAIN_OpenKnxId, MAIN_ApplicationNumber, MAIN_ApplicationVersion, firmwareRevision);

//     // print values of parameters if device is already configured
//     appSetup();


//     // start the framework.
//     knx.start();

// #ifdef LED_YELLOW_PIN
//     digitalWrite(LED_YELLOW_PIN, LOW);
// #endif
}

void loop()
{
    openknx.loop();
}


